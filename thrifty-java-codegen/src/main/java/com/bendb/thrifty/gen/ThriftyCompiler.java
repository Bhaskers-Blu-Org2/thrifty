package com.bendb.thrifty.gen;

import com.bendb.thrifty.schema.EnumType;
import com.bendb.thrifty.schema.Loader;
import com.bendb.thrifty.schema.Location;
import com.bendb.thrifty.schema.NamespaceScope;
import com.bendb.thrifty.schema.Schema;
import com.bendb.thrifty.schema.StructType;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 *
 */
public class ThriftyCompiler {
    private static final String FILE_COMMENT = "Automatically generated by the Thrifty compiler; do not edit!\n";

    private static final String OUT_PREFIX = "--out=";
    private static final String PATH_PREFIX = "--path=";
    private static final String LIST_TYPE_PREFIX = "--list-type=";
    private static final String SET_TYPE_PREFIX = "--set-type=";
    private static final String MAP_TYPE_PREFIX = "--map-type=";

    private File outputDirectory;
    private List<String> thriftFiles = new ArrayList<>();
    private List<String> searchPath = new ArrayList<>();
    private ClassName listTypeName;
    private ClassName setTypeName;
    private ClassName mapTypeName;

    public static void main(String[] args) {
        try {
            ThriftyCompiler compiler = withArgs(args);
            compiler.compile();
        } catch (Exception e) {
            System.err.println("Unhandled exception:");
            e.printStackTrace(System.err);
            System.exit(1);
        }
    }

    public static ThriftyCompiler withArgs(String[] args) {
        ThriftyCompiler compiler = new ThriftyCompiler();

        for (String arg : args) {
            if (arg.startsWith(OUT_PREFIX)) {
                String path = arg.substring(OUT_PREFIX.length());
                compiler.setOutputDirectory(new File(path));
            } else if (arg.startsWith(PATH_PREFIX)) {
                String dirname = arg.substring(PATH_PREFIX.length());
                compiler.addSearchDirectory(dirname);
            } else if (arg.startsWith(LIST_TYPE_PREFIX)) {
                String typename = arg.substring(LIST_TYPE_PREFIX.length());
                compiler.setListType(typename);
            } else if (arg.startsWith(SET_TYPE_PREFIX)) {
                String typename = arg.substring(SET_TYPE_PREFIX.length());
                compiler.setSetType(typename);
            } else if (arg.startsWith(MAP_TYPE_PREFIX)) {
                String typename = arg.substring(MAP_TYPE_PREFIX.length());
                compiler.setMapType(typename);
            } else if (arg.startsWith("-")) {
                throw new IllegalArgumentException("Unrecognized argument: " + arg);
            } else {
                compiler.addThriftFile(arg);
            }
        }

        if (compiler.outputDirectory == null) {
            throw new IllegalArgumentException("Output path must be provided (missing --out=path)");
        }

        return compiler;
    }

    public ThriftyCompiler addThriftFile(String path) {
        thriftFiles.add(path);
        return this;
    }

    public ThriftyCompiler addSearchDirectory(String path) {
        searchPath.add(path);
        return this;
    }

    public ThriftyCompiler setListType(String typename) {
        listTypeName = constructClassName(typename);
        return this;
    }

    public ThriftyCompiler setSetType(String typename) {
        setTypeName = constructClassName(typename);
        return this;
    }

    public ThriftyCompiler setMapType(String typename) {
        mapTypeName = constructClassName(typename);
        return this;
    }

    public ThriftyCompiler setOutputDirectory(File directory) {
        outputDirectory = directory;
        return this;
    }

    public void compile() throws IOException {
        Loader loader = new Loader();
        for (String thriftFile : thriftFiles) {
            loader.addThriftFile(thriftFile);
        }

        for (String dir : searchPath) {
            loader.addIncludePath(new File(dir));
        }

        ThriftyCodeGenerator gen = new ThriftyCodeGenerator();
        if (listTypeName != null) {
            gen = gen.withListType(listTypeName);
        }

        if (setTypeName != null) {
            gen = gen.withSetType(setTypeName);
        }

        if (mapTypeName != null) {
            gen = gen.withMapType(mapTypeName);
        }

        Schema schema = loader.load();

        for (EnumType enumType : schema.enums()) {
            TypeSpec spec = gen.buildEnum(enumType);
            String packageName = enumType.getNamespaceFor(NamespaceScope.JAVA);
            writeType(spec, packageName, enumType.location());
        }

        for (StructType structType : schema.structs()) {
            TypeSpec spec = gen.buildStruct(structType);
            String packageName = structType.getNamespaceFor(NamespaceScope.JAVA);
            writeType(spec, packageName, structType.location());
        }

        for (StructType structType : schema.exceptions()) {
            TypeSpec spec = gen.buildStruct(structType);
            String packageName = structType.getNamespaceFor(NamespaceScope.JAVA);
            writeType(spec, packageName, structType.location());
        }

        for (StructType structType : schema.unions()) {
            TypeSpec spec = gen.buildStruct(structType);
            String packageName = structType.getNamespaceFor(NamespaceScope.JAVA);
            writeType(spec, packageName, structType.location());
        }

        // TODO: Services, constants.
    }

    private void writeType(TypeSpec type, String packageName, Location location) throws IOException {
        JavaFile.Builder builder = JavaFile.builder(packageName, type)
                .skipJavaLangImports(true)
                .addFileComment("$L", FILE_COMMENT);

        if (location != null) {
            builder.addFileComment("Source file: $L\n", location);
        }

        JavaFile javaFile = builder
                .build();

        javaFile.writeTo(outputDirectory);
    }

    private ClassName constructClassName(String name) {
        return ClassName.bestGuess(name);
    }
}
